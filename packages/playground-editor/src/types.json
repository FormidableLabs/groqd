{
  "NOTE": "This file is automatically generated via the gather-types script",
  "zod": {
    "index.d.ts": "export * from \"./lib\";\nexport as namespace Zod;\n",
    "lib/types.d.ts": "import { enumUtil } from \"./helpers/enumUtil\";\nimport { errorUtil } from \"./helpers/errorUtil\";\nimport { AsyncParseReturnType, ParseContext, ParseInput, ParseParams, ParseReturnType, ParseStatus, SyncParseReturnType } from \"./helpers/parseUtil\";\nimport { partialUtil } from \"./helpers/partialUtil\";\nimport { Primitive } from \"./helpers/typeAliases\";\nimport { util } from \"./helpers/util\";\nimport { IssueData, StringValidation, ZodCustomIssue, ZodError, ZodErrorMap } from \"./ZodError\";\nexport declare type RefinementCtx = {\n    addIssue: (arg: IssueData) => void;\n    path: (string | number)[];\n};\nexport declare type ZodRawShape = {\n    [k: string]: ZodTypeAny;\n};\nexport declare type ZodTypeAny = ZodType<any, any, any>;\nexport declare type TypeOf<T extends ZodType<any, any, any>> = T[\"_output\"];\nexport declare type input<T extends ZodType<any, any, any>> = T[\"_input\"];\nexport declare type output<T extends ZodType<any, any, any>> = T[\"_output\"];\nexport type { TypeOf as infer };\nexport declare type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, \"code\">>;\nexport interface ZodTypeDef {\n    errorMap?: ZodErrorMap;\n    description?: string;\n}\nexport declare type RawCreateParams = {\n    errorMap?: ZodErrorMap;\n    invalid_type_error?: string;\n    required_error?: string;\n    description?: string;\n} | undefined;\nexport declare type ProcessedCreateParams = {\n    errorMap?: ZodErrorMap;\n    description?: string;\n};\nexport declare type SafeParseSuccess<Output> = {\n    success: true;\n    data: Output;\n};\nexport declare type SafeParseError<Input> = {\n    success: false;\n    error: ZodError<Input>;\n};\nexport declare type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;\nexport declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {\n    readonly _type: Output;\n    readonly _output: Output;\n    readonly _input: Input;\n    readonly _def: Def;\n    get description(): string | undefined;\n    abstract _parse(input: ParseInput): ParseReturnType<Output>;\n    _getType(input: ParseInput): string;\n    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;\n    _processInputParams(input: ParseInput): {\n        status: ParseStatus;\n        ctx: ParseContext;\n    };\n    _parseSync(input: ParseInput): SyncParseReturnType<Output>;\n    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;\n    parse(data: unknown, params?: Partial<ParseParams>): Output;\n    safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;\n    parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;\n    safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;\n    /** Alias of safeParseAsync */\n    spa: (data: unknown, params?: Partial<ParseParams> | undefined) => Promise<SafeParseReturnType<Input, Output>>;\n    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;\n    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;\n    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;\n    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;\n    _refinement(refinement: RefinementEffect<Output>[\"refinement\"]): ZodEffects<this, Output, Input>;\n    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;\n    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;\n    constructor(def: Def);\n    optional(): ZodOptional<this>;\n    nullable(): ZodNullable<this>;\n    nullish(): ZodNullable<ZodOptional<this>>;\n    array(): ZodArray<this>;\n    promise(): ZodPromise<this>;\n    or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]>;\n    and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;\n    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;\n    default(def: util.noUndefined<Input>): ZodDefault<this>;\n    default(def: () => util.noUndefined<Input>): ZodDefault<this>;\n    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;\n    catch(def: Input): ZodCatch<this>;\n    catch(def: () => Input): ZodCatch<this>;\n    describe(description: string): this;\n    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;\n    isOptional(): boolean;\n    isNullable(): boolean;\n}\nexport declare type ZodStringCheck = {\n    kind: \"min\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"length\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"email\";\n    message?: string;\n} | {\n    kind: \"url\";\n    message?: string;\n} | {\n    kind: \"uuid\";\n    message?: string;\n} | {\n    kind: \"cuid\";\n    message?: string;\n} | {\n    kind: \"startsWith\";\n    value: string;\n    message?: string;\n} | {\n    kind: \"endsWith\";\n    value: string;\n    message?: string;\n} | {\n    kind: \"regex\";\n    regex: RegExp;\n    message?: string;\n} | {\n    kind: \"trim\";\n    message?: string;\n} | {\n    kind: \"datetime\";\n    offset: boolean;\n    precision: number | null;\n    message?: string;\n};\nexport interface ZodStringDef extends ZodTypeDef {\n    checks: ZodStringCheck[];\n    typeName: ZodFirstPartyTypeKind.ZodString;\n    coerce: boolean;\n}\nexport declare class ZodString extends ZodType<string, ZodStringDef> {\n    _parse(input: ParseInput): ParseReturnType<string>;\n    protected _regex: (regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage | undefined) => ZodEffects<this, string, string>;\n    _addCheck(check: ZodStringCheck): ZodString;\n    email(message?: errorUtil.ErrMessage): ZodString;\n    url(message?: errorUtil.ErrMessage): ZodString;\n    uuid(message?: errorUtil.ErrMessage): ZodString;\n    cuid(message?: errorUtil.ErrMessage): ZodString;\n    datetime(options?: string | {\n        message?: string | undefined;\n        precision?: number | null;\n        offset?: boolean;\n    }): ZodString;\n    regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;\n    startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;\n    endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;\n    min(minLength: number, message?: errorUtil.ErrMessage): ZodString;\n    max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;\n    length(len: number, message?: errorUtil.ErrMessage): ZodString;\n    /**\n     * @deprecated Use z.string().min(1) instead.\n     * @see {@link ZodString.min}\n     */\n    nonempty: (message?: errorUtil.ErrMessage | undefined) => ZodString;\n    trim: () => ZodString;\n    get isDatetime(): boolean;\n    get isEmail(): boolean;\n    get isURL(): boolean;\n    get isUUID(): boolean;\n    get isCUID(): boolean;\n    get minLength(): number | null;\n    get maxLength(): number | null;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: true | undefined;\n    }) | undefined) => ZodString;\n}\nexport declare type ZodNumberCheck = {\n    kind: \"min\";\n    value: number;\n    inclusive: boolean;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: number;\n    inclusive: boolean;\n    message?: string;\n} | {\n    kind: \"int\";\n    message?: string;\n} | {\n    kind: \"multipleOf\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"finite\";\n    message?: string;\n};\nexport interface ZodNumberDef extends ZodTypeDef {\n    checks: ZodNumberCheck[];\n    typeName: ZodFirstPartyTypeKind.ZodNumber;\n    coerce: boolean;\n}\nexport declare class ZodNumber extends ZodType<number, ZodNumberDef> {\n    _parse(input: ParseInput): ParseReturnType<number>;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodNumber;\n    gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    min: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;\n    gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    max: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;\n    lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    protected setLimit(kind: \"min\" | \"max\", value: number, inclusive: boolean, message?: string): ZodNumber;\n    _addCheck(check: ZodNumberCheck): ZodNumber;\n    int(message?: errorUtil.ErrMessage): ZodNumber;\n    positive(message?: errorUtil.ErrMessage): ZodNumber;\n    negative(message?: errorUtil.ErrMessage): ZodNumber;\n    nonpositive(message?: errorUtil.ErrMessage): ZodNumber;\n    nonnegative(message?: errorUtil.ErrMessage): ZodNumber;\n    multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    finite(message?: errorUtil.ErrMessage): ZodNumber;\n    step: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;\n    get minValue(): number | null;\n    get maxValue(): number | null;\n    get isInt(): boolean;\n}\nexport interface ZodBigIntDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodBigInt;\n    coerce: boolean;\n}\nexport declare class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {\n    _parse(input: ParseInput): ParseReturnType<bigint>;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBigInt;\n}\nexport interface ZodBooleanDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodBoolean;\n    coerce: boolean;\n}\nexport declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {\n    _parse(input: ParseInput): ParseReturnType<boolean>;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBoolean;\n}\nexport declare type ZodDateCheck = {\n    kind: \"min\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: number;\n    message?: string;\n};\nexport interface ZodDateDef extends ZodTypeDef {\n    checks: ZodDateCheck[];\n    coerce: boolean;\n    typeName: ZodFirstPartyTypeKind.ZodDate;\n}\nexport declare class ZodDate extends ZodType<Date, ZodDateDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    _addCheck(check: ZodDateCheck): ZodDate;\n    min(minDate: Date, message?: errorUtil.ErrMessage): ZodDate;\n    max(maxDate: Date, message?: errorUtil.ErrMessage): ZodDate;\n    get minDate(): Date | null;\n    get maxDate(): Date | null;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodDate;\n}\nexport interface ZodSymbolDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodSymbol;\n}\nexport declare class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodSymbol;\n}\nexport interface ZodUndefinedDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodUndefined;\n}\nexport declare class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    params?: RawCreateParams;\n    static create: (params?: RawCreateParams) => ZodUndefined;\n}\nexport interface ZodNullDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodNull;\n}\nexport declare class ZodNull extends ZodType<null, ZodNullDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodNull;\n}\nexport interface ZodAnyDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodAny;\n}\nexport declare class ZodAny extends ZodType<any, ZodAnyDef> {\n    _any: true;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodAny;\n}\nexport interface ZodUnknownDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodUnknown;\n}\nexport declare class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {\n    _unknown: true;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodUnknown;\n}\nexport interface ZodNeverDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodNever;\n}\nexport declare class ZodNever extends ZodType<never, ZodNeverDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodNever;\n}\nexport interface ZodVoidDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodVoid;\n}\nexport declare class ZodVoid extends ZodType<void, ZodVoidDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodVoid;\n}\nexport interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    type: T;\n    typeName: ZodFirstPartyTypeKind.ZodArray;\n    exactLength: {\n        value: number;\n        message?: string;\n    } | null;\n    minLength: {\n        value: number;\n        message?: string;\n    } | null;\n    maxLength: {\n        value: number;\n        message?: string;\n    } | null;\n}\nexport declare type ArrayCardinality = \"many\" | \"atleastone\";\nexport declare type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = \"many\"> = Cardinality extends \"atleastone\" ? [T[\"_output\"], ...T[\"_output\"][]] : T[\"_output\"][];\nexport declare class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = \"many\"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends \"atleastone\" ? [T[\"_input\"], ...T[\"_input\"][]] : T[\"_input\"][]> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get element(): T;\n    min(minLength: number, message?: errorUtil.ErrMessage): this;\n    max(maxLength: number, message?: errorUtil.ErrMessage): this;\n    length(len: number, message?: errorUtil.ErrMessage): this;\n    nonempty(message?: errorUtil.ErrMessage): ZodArray<T, \"atleastone\">;\n    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1, \"many\">;\n}\nexport declare type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, \"atleastone\">;\nexport declare namespace objectUtil {\n    export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {\n        [k in Exclude<keyof U, keyof V>]: U[k];\n    } & V;\n    type optionalKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? k : never;\n    }[keyof T];\n    type requiredKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? never : k;\n    }[keyof T];\n    export type addQuestionMarks<T extends object> = Partial<Pick<T, optionalKeys<T>>> & Pick<T, requiredKeys<T>>;\n    export type identity<T> = T;\n    export type flatten<T extends object> = identity<{\n        [k in keyof T]: T[k];\n    }>;\n    export type noNeverKeys<T extends ZodRawShape> = {\n        [k in keyof T]: [T[k]] extends [never] ? never : k;\n    }[keyof T];\n    export type noNever<T extends ZodRawShape> = identity<{\n        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n    }>;\n    export const mergeShapes: <U extends ZodRawShape, T extends ZodRawShape>(first: U, second: T) => T & U;\n    export {};\n}\nexport declare type extendShape<A, B> = Omit<A, keyof B> & B;\nexport declare type UnknownKeysParam = \"passthrough\" | \"strict\" | \"strip\";\nexport interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodObject;\n    shape: () => T;\n    catchall: Catchall;\n    unknownKeys: UnknownKeys;\n}\nexport declare type baseObjectOutputType<Shape extends ZodRawShape> = objectUtil.flatten<objectUtil.addQuestionMarks<{\n    [k in keyof Shape]: Shape[k][\"_output\"];\n}>>;\nexport declare type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny> = ZodTypeAny extends Catchall ? baseObjectOutputType<Shape> : objectUtil.flatten<baseObjectOutputType<Shape> & {\n    [k: string]: Catchall[\"_output\"];\n}>;\nexport declare type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<objectUtil.addQuestionMarks<{\n    [k in keyof Shape]: Shape[k][\"_input\"];\n}>>;\nexport declare type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny> = ZodTypeAny extends Catchall ? baseObjectInputType<Shape> : objectUtil.flatten<baseObjectInputType<Shape> & {\n    [k: string]: Catchall[\"_input\"];\n}>;\nexport declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;\nexport declare type SomeZodObject = ZodObject<ZodRawShape, UnknownKeysParam, ZodTypeAny, any, any>;\nexport declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = \"strip\", Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall>, Input = objectInputType<T, Catchall>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {\n    private _cached;\n    _getCached(): {\n        shape: T;\n        keys: string[];\n    };\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get shape(): T;\n    strict(message?: errorUtil.ErrMessage): ZodObject<T, \"strict\", Catchall>;\n    strip(): ZodObject<T, \"strip\", Catchall>;\n    passthrough(): ZodObject<T, \"passthrough\", Catchall>;\n    /**\n     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n     * If you want to pass through unknown properties, use `.passthrough()` instead.\n     */\n    nonstrict: () => ZodObject<T, \"passthrough\", Catchall>;\n    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<extendShape<T, Augmentation>, UnknownKeys, Catchall, objectOutputType<extendShape<T, Augmentation>, Catchall>, objectInputType<extendShape<T, Augmentation>, Catchall>>;\n    extend: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<extendShape<T, Augmentation>, UnknownKeys, Catchall, objectOutputType<extendShape<T, Augmentation>, Catchall>, objectInputType<extendShape<T, Augmentation>, Catchall>>;\n    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {\n        [k in Key]: Schema;\n    }, UnknownKeys, Catchall>;\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge<Incoming extends AnyZodObject>(merging: Incoming): ZodObject<extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>, Incoming[\"_def\"][\"unknownKeys\"], Incoming[\"_def\"][\"catchall\"]>;\n    catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;\n    pick<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;\n    omit<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;\n    deepPartial(): partialUtil.DeepPartial<this>;\n    partial(): ZodObject<{\n        [k in keyof T]: ZodOptional<T[k]>;\n    }, UnknownKeys, Catchall>;\n    partial<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<objectUtil.noNever<{\n        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];\n    }>, UnknownKeys, Catchall>;\n    required(): ZodObject<{\n        [k in keyof T]: deoptional<T[k]>;\n    }, UnknownKeys, Catchall>;\n    required<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<objectUtil.noNever<{\n        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];\n    }>, UnknownKeys, Catchall>;\n    keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;\n    static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][\"_output\"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][\"_output\"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][\"_input\"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][\"_input\"]; }>[k_3]; }>;\n    static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, \"strict\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][\"_output\"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][\"_output\"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][\"_input\"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][\"_input\"]; }>[k_3]; }>;\n    static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][\"_output\"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k][\"_output\"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][\"_input\"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2][\"_input\"]; }>[k_3]; }>;\n}\nexport declare type AnyZodObject = ZodObject<any, any, any>;\nexport declare type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;\nexport interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[\n    ZodTypeAny,\n    ZodTypeAny,\n    ...ZodTypeAny[]\n]>> extends ZodTypeDef {\n    options: T;\n    typeName: ZodFirstPartyTypeKind.ZodUnion;\n}\nexport declare class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number][\"_output\"], ZodUnionDef<T>, T[number][\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get options(): T;\n    static create: <T_1 extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;\n}\nexport declare type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<{\n    [key in Discriminator]: ZodTypeAny;\n} & ZodRawShape, any, any>;\nexport interface ZodDiscriminatedUnionDef<Discriminator extends string, Options extends ZodDiscriminatedUnionOption<any>[] = ZodDiscriminatedUnionOption<any>[]> extends ZodTypeDef {\n    discriminator: Discriminator;\n    options: Options;\n    optionsMap: Map<Primitive, ZodDiscriminatedUnionOption<any>>;\n    typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;\n}\nexport declare class ZodDiscriminatedUnion<Discriminator extends string, Options extends ZodDiscriminatedUnionOption<Discriminator>[]> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get discriminator(): Discriminator;\n    get options(): Options;\n    get optionsMap(): Map<Primitive, ZodDiscriminatedUnionOption<any>>;\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create<Discriminator extends string, Types extends [\n        ZodDiscriminatedUnionOption<Discriminator>,\n        ...ZodDiscriminatedUnionOption<Discriminator>[]\n    ]>(discriminator: Discriminator, options: Types, params?: RawCreateParams): ZodDiscriminatedUnion<Discriminator, Types>;\n}\nexport interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    left: T;\n    right: U;\n    typeName: ZodFirstPartyTypeKind.ZodIntersection;\n}\nexport declare class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T[\"_output\"] & U[\"_output\"], ZodIntersectionDef<T, U>, T[\"_input\"] & U[\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;\n}\nexport declare type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport declare type AssertArray<T> = T extends any[] ? T : never;\nexport declare type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{\n    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][\"_output\"] : never;\n}>;\nexport declare type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest[\"_output\"][]] : OutputTypeOfTuple<T>;\nexport declare type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{\n    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][\"_input\"] : never;\n}>;\nexport declare type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest[\"_input\"][]] : InputTypeOfTuple<T>;\nexport interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {\n    items: T;\n    rest: Rest;\n    typeName: ZodFirstPartyTypeKind.ZodTuple;\n}\nexport declare type AnyZodTuple = ZodTuple<[\n    ZodTypeAny,\n    ...ZodTypeAny[]\n] | [], ZodTypeAny | null>;\nexport declare class ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get items(): T;\n    rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;\n    static create: <T_1 extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;\n}\nexport interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    valueType: Value;\n    keyType: Key;\n    typeName: ZodFirstPartyTypeKind.ZodRecord;\n}\nexport declare type KeySchema = ZodType<string | number | symbol, any, any>;\nexport declare type RecordType<K extends string | number | symbol, V> = [\n    string\n] extends [K] ? Record<K, V> : [number] extends [K] ? Record<K, V> : [symbol] extends [K] ? Record<K, V> : Partial<Record<K, V>>;\nexport declare class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<RecordType<Key[\"_output\"], Value[\"_output\"]>, ZodRecordDef<Key, Value>, RecordType<Key[\"_input\"], Value[\"_input\"]>> {\n    get keySchema(): Key;\n    get valueSchema(): Value;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get element(): Value;\n    static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;\n    static create<Keys extends KeySchema, Value extends ZodTypeAny>(keySchema: Keys, valueType: Value, params?: RawCreateParams): ZodRecord<Keys, Value>;\n}\nexport interface ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    valueType: Value;\n    keyType: Key;\n    typeName: ZodFirstPartyTypeKind.ZodMap;\n}\nexport declare class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Map<Key[\"_output\"], Value[\"_output\"]>, ZodMapDef<Key, Value>, Map<Key[\"_input\"], Value[\"_input\"]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <Key_1 extends ZodTypeAny = ZodTypeAny, Value_1 extends ZodTypeAny = ZodTypeAny>(keyType: Key_1, valueType: Value_1, params?: RawCreateParams) => ZodMap<Key_1, Value_1>;\n}\nexport interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    valueType: Value;\n    typeName: ZodFirstPartyTypeKind.ZodSet;\n    minSize: {\n        value: number;\n        message?: string;\n    } | null;\n    maxSize: {\n        value: number;\n        message?: string;\n    } | null;\n}\nexport declare class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Set<Value[\"_output\"]>, ZodSetDef<Value>, Set<Value[\"_input\"]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    min(minSize: number, message?: errorUtil.ErrMessage): this;\n    max(maxSize: number, message?: errorUtil.ErrMessage): this;\n    size(size: number, message?: errorUtil.ErrMessage): this;\n    nonempty(message?: errorUtil.ErrMessage): ZodSet<Value>;\n    static create: <Value_1 extends ZodTypeAny = ZodTypeAny>(valueType: Value_1, params?: RawCreateParams) => ZodSet<Value_1>;\n}\nexport interface ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple<any, any>, Returns extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    args: Args;\n    returns: Returns;\n    typeName: ZodFirstPartyTypeKind.ZodFunction;\n}\nexport declare type OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args[\"_input\"] extends Array<any> ? (...args: Args[\"_input\"]) => Returns[\"_output\"] : never;\nexport declare type InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args[\"_output\"] extends Array<any> ? (...args: Args[\"_output\"]) => Returns[\"_input\"] : never;\nexport declare class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<OuterTypeOfFunction<Args, Returns>, ZodFunctionDef<Args, Returns>, InnerTypeOfFunction<Args, Returns>> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    parameters(): Args;\n    returnType(): Returns;\n    args<Items extends Parameters<typeof ZodTuple[\"create\"]>[0]>(...items: Items): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns>;\n    returns<NewReturnType extends ZodType<any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType>;\n    implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): ReturnType<F> extends Returns[\"_output\"] ? (...args: Args[\"_input\"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;\n    strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns>;\n    validate: <F extends InnerTypeOfFunction<Args, Returns>>(func: F) => ReturnType<F> extends Returns[\"_output\"] ? (...args: Args[\"_input\"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;\n    static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;\n    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;\n    static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;\n    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;\n}\nexport interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    getter: () => T;\n    typeName: ZodFirstPartyTypeKind.ZodLazy;\n}\nexport declare class ZodLazy<T extends ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {\n    get schema(): T;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <T_1 extends ZodTypeAny>(getter: () => T_1, params?: RawCreateParams) => ZodLazy<T_1>;\n}\nexport interface ZodLiteralDef<T = any> extends ZodTypeDef {\n    value: T;\n    typeName: ZodFirstPartyTypeKind.ZodLiteral;\n}\nexport declare class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get value(): T;\n    static create: <T_1 extends Primitive>(value: T_1, params?: RawCreateParams) => ZodLiteral<T_1>;\n}\nexport declare type ArrayKeys = keyof any[];\nexport declare type Indices<T> = Exclude<keyof T, ArrayKeys>;\nexport declare type EnumValues = [string, ...string[]];\nexport declare type Values<T extends EnumValues> = {\n    [k in T[number]]: k;\n};\nexport interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {\n    values: T;\n    typeName: ZodFirstPartyTypeKind.ZodEnum;\n}\nexport declare type Writeable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\ndeclare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;\ndeclare function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;\nexport declare class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get options(): T;\n    get enum(): Values<T>;\n    get Values(): Values<T>;\n    get Enum(): Values<T>;\n    static create: typeof createZodEnum;\n}\nexport interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {\n    values: T;\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum;\n}\nexport declare type EnumLike = {\n    [k: string]: string | number;\n    [nu: number]: string;\n};\nexport declare class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>> {\n    _parse(input: ParseInput): ParseReturnType<T[keyof T]>;\n    get enum(): T;\n    static create: <T_1 extends EnumLike>(values: T_1, params?: RawCreateParams) => ZodNativeEnum<T_1>;\n}\nexport interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    type: T;\n    typeName: ZodFirstPartyTypeKind.ZodPromise;\n}\nexport declare class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T[\"_output\"]>, ZodPromiseDef<T>, Promise<T[\"_input\"]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;\n}\nexport declare type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;\nexport declare type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;\nexport declare type RefinementEffect<T> = {\n    type: \"refinement\";\n    refinement: (arg: T, ctx: RefinementCtx) => any;\n};\nexport declare type TransformEffect<T> = {\n    type: \"transform\";\n    transform: (arg: T, ctx: RefinementCtx) => any;\n};\nexport declare type PreprocessEffect<T> = {\n    type: \"preprocess\";\n    transform: (arg: T) => any;\n};\nexport declare type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;\nexport interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    schema: T;\n    typeName: ZodFirstPartyTypeKind.ZodEffects;\n    effect: Effect<any>;\n}\nexport declare class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {\n    innerType(): T;\n    sourceType(): T;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I[\"_output\"]>, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], input<I>>;\n    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], unknown>;\n}\nexport { ZodEffects as ZodTransformer };\nexport interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    typeName: ZodFirstPartyTypeKind.ZodOptional;\n}\nexport declare type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;\nexport declare class ZodOptional<T extends ZodTypeAny> extends ZodType<T[\"_output\"] | undefined, ZodOptionalDef<T>, T[\"_input\"] | undefined> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    unwrap(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;\n}\nexport interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    typeName: ZodFirstPartyTypeKind.ZodNullable;\n}\nexport declare type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;\nexport declare class ZodNullable<T extends ZodTypeAny> extends ZodType<T[\"_output\"] | null, ZodNullableDef<T>, T[\"_input\"] | null> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    unwrap(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;\n}\nexport interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    defaultValue: () => util.noUndefined<T[\"_input\"]>;\n    typeName: ZodFirstPartyTypeKind.ZodDefault;\n}\nexport declare class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T[\"_output\"]>, ZodDefaultDef<T>, T[\"_input\"] | undefined> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    removeDefault(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        default: T_1[\"_input\"] | (() => util.noUndefined<T_1[\"_input\"]>);\n    }) => ZodDefault<T_1>;\n}\nexport interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    defaultValue: () => T[\"_input\"];\n    typeName: ZodFirstPartyTypeKind.ZodCatch;\n}\nexport declare class ZodCatch<T extends ZodTypeAny> extends ZodType<util.noUndefined<T[\"_output\"]>, ZodCatchDef<T>, T[\"_input\"] | undefined> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    removeDefault(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        default: T_1[\"_input\"] | (() => T_1[\"_input\"]);\n    }) => ZodCatch<T_1>;\n}\nexport interface ZodNaNDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodNaN;\n}\nexport declare class ZodNaN extends ZodType<number, ZodNaNDef> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    static create: (params?: RawCreateParams) => ZodNaN;\n}\nexport interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {\n    type: T;\n    typeName: ZodFirstPartyTypeKind.ZodBranded;\n}\nexport declare const BRAND: unique symbol;\nexport declare type BRAND<T extends string | number | symbol> = {\n    [BRAND]: {\n        [k in T]: true;\n    };\n};\nexport declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T[\"_output\"] & BRAND<B>, ZodBrandedDef<T>, T[\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    unwrap(): T;\n}\nexport interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {\n    in: A;\n    out: B;\n    typeName: ZodFirstPartyTypeKind.ZodPipeline;\n}\nexport declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B[\"_output\"], ZodPipelineDef<A, B>, A[\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;\n}\nexport declare const custom: <T>(check?: ((data: unknown) => any) | undefined, params?: Parameters<ZodTypeAny[\"refine\"]>[1], fatal?: boolean | undefined) => ZodType<T, ZodTypeDef, T>;\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport declare const late: {\n    object: <T extends ZodRawShape>(shape: () => T, params?: RawCreateParams) => ZodObject<T, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][\"_output\"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][\"_output\"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][\"_input\"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][\"_input\"]; }>[k_3]; }>;\n};\nexport declare enum ZodFirstPartyTypeKind {\n    ZodString = \"ZodString\",\n    ZodNumber = \"ZodNumber\",\n    ZodNaN = \"ZodNaN\",\n    ZodBigInt = \"ZodBigInt\",\n    ZodBoolean = \"ZodBoolean\",\n    ZodDate = \"ZodDate\",\n    ZodSymbol = \"ZodSymbol\",\n    ZodUndefined = \"ZodUndefined\",\n    ZodNull = \"ZodNull\",\n    ZodAny = \"ZodAny\",\n    ZodUnknown = \"ZodUnknown\",\n    ZodNever = \"ZodNever\",\n    ZodVoid = \"ZodVoid\",\n    ZodArray = \"ZodArray\",\n    ZodObject = \"ZodObject\",\n    ZodUnion = \"ZodUnion\",\n    ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\",\n    ZodIntersection = \"ZodIntersection\",\n    ZodTuple = \"ZodTuple\",\n    ZodRecord = \"ZodRecord\",\n    ZodMap = \"ZodMap\",\n    ZodSet = \"ZodSet\",\n    ZodFunction = \"ZodFunction\",\n    ZodLazy = \"ZodLazy\",\n    ZodLiteral = \"ZodLiteral\",\n    ZodEnum = \"ZodEnum\",\n    ZodEffects = \"ZodEffects\",\n    ZodNativeEnum = \"ZodNativeEnum\",\n    ZodOptional = \"ZodOptional\",\n    ZodNullable = \"ZodNullable\",\n    ZodDefault = \"ZodDefault\",\n    ZodCatch = \"ZodCatch\",\n    ZodPromise = \"ZodPromise\",\n    ZodBranded = \"ZodBranded\",\n    ZodPipeline = \"ZodPipeline\"\n}\nexport declare type ZodFirstPartySchemaTypes = ZodString | ZodNumber | ZodNaN | ZodBigInt | ZodBoolean | ZodDate | ZodUndefined | ZodNull | ZodAny | ZodUnknown | ZodNever | ZodVoid | ZodArray<any, any> | ZodObject<any, any, any, any, any> | ZodUnion<any> | ZodDiscriminatedUnion<any, any> | ZodIntersection<any, any> | ZodTuple<any, any> | ZodRecord<any, any> | ZodMap<any> | ZodSet<any> | ZodFunction<any, any> | ZodLazy<any> | ZodLiteral<any> | ZodEnum<any> | ZodEffects<any, any, any> | ZodNativeEnum<any> | ZodOptional<any> | ZodNullable<any> | ZodDefault<any> | ZodCatch<any> | ZodPromise<any> | ZodBranded<any, any> | ZodPipeline<any, any>;\ndeclare abstract class Class {\n    constructor(..._: any[]);\n}\ndeclare const instanceOfType: <T extends typeof Class>(cls: T, params?: Parameters<ZodTypeAny[\"refine\"]>[1]) => ZodType<InstanceType<T>, ZodTypeDef, InstanceType<T>>;\ndeclare const stringType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: true | undefined;\n}) | undefined) => ZodString;\ndeclare const numberType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodNumber;\ndeclare const nanType: (params?: RawCreateParams) => ZodNaN;\ndeclare const bigIntType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodBigInt;\ndeclare const booleanType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodBoolean;\ndeclare const dateType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodDate;\ndeclare const symbolType: (params?: RawCreateParams) => ZodSymbol;\ndeclare const undefinedType: (params?: RawCreateParams) => ZodUndefined;\ndeclare const nullType: (params?: RawCreateParams) => ZodNull;\ndeclare const anyType: (params?: RawCreateParams) => ZodAny;\ndeclare const unknownType: (params?: RawCreateParams) => ZodUnknown;\ndeclare const neverType: (params?: RawCreateParams) => ZodNever;\ndeclare const voidType: (params?: RawCreateParams) => ZodVoid;\ndeclare const arrayType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodArray<T, \"many\">;\ndeclare const objectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][\"_output\"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][\"_output\"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][\"_input\"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][\"_input\"]; }>[k_3]; }>;\ndeclare const strictObjectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, \"strict\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][\"_output\"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T]: T[k][\"_output\"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][\"_input\"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T]: T[k_2][\"_input\"]; }>[k_3]; }>;\ndeclare const unionType: <T extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T, params?: RawCreateParams) => ZodUnion<T>;\ndeclare const discriminatedUnionType: typeof ZodDiscriminatedUnion.create;\ndeclare const intersectionType: <T extends ZodTypeAny, U extends ZodTypeAny>(left: T, right: U, params?: RawCreateParams) => ZodIntersection<T, U>;\ndeclare const tupleType: <T extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T, params?: RawCreateParams) => ZodTuple<T, null>;\ndeclare const recordType: typeof ZodRecord.create;\ndeclare const mapType: <Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny>(keyType: Key, valueType: Value, params?: RawCreateParams) => ZodMap<Key, Value>;\ndeclare const setType: <Value extends ZodTypeAny = ZodTypeAny>(valueType: Value, params?: RawCreateParams) => ZodSet<Value>;\ndeclare const functionType: typeof ZodFunction.create;\ndeclare const lazyType: <T extends ZodTypeAny>(getter: () => T, params?: RawCreateParams) => ZodLazy<T>;\ndeclare const literalType: <T extends Primitive>(value: T, params?: RawCreateParams) => ZodLiteral<T>;\ndeclare const enumType: typeof createZodEnum;\ndeclare const nativeEnumType: <T extends EnumLike>(values: T, params?: RawCreateParams) => ZodNativeEnum<T>;\ndeclare const promiseType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodPromise<T>;\ndeclare const effectsType: <I extends ZodTypeAny>(schema: I, effect: Effect<I[\"_output\"]>, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], input<I>>;\ndeclare const optionalType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodOptional<T>;\ndeclare const nullableType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodNullable<T>;\ndeclare const preprocessType: <I extends ZodTypeAny>(preprocess: (arg: unknown) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], unknown>;\ndeclare const pipelineType: typeof ZodPipeline.create;\ndeclare const ostring: () => ZodOptional<ZodString>;\ndeclare const onumber: () => ZodOptional<ZodNumber>;\ndeclare const oboolean: () => ZodOptional<ZodBoolean>;\nexport declare const coerce: {\n    string: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: true | undefined;\n    }) | undefined) => ZodString;\n    number: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodNumber;\n    boolean: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBoolean;\n    bigint: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBigInt;\n    date: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodDate;\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport declare const NEVER: never;\n",
    "lib/index.d.ts": "import * as mod from \"./external\";\nexport * from \"./external\";\nexport { mod as z };\nexport default mod;\n",
    "lib/external.d.ts": "export * from \"./errors\";\nexport * from \"./helpers/parseUtil\";\nexport * from \"./helpers/typeAliases\";\nexport * from \"./helpers/util\";\nexport * from \"./types\";\nexport * from \"./ZodError\";\n",
    "lib/errors.d.ts": "import defaultErrorMap from \"./locales/en\";\nimport type { ZodErrorMap } from \"./ZodError\";\nexport { defaultErrorMap };\nexport declare function setErrorMap(map: ZodErrorMap): void;\nexport declare function getErrorMap(): ZodErrorMap;\n",
    "lib/ZodError.d.ts": "import type { TypeOf, ZodType } from \".\";\nimport { Primitive } from \"./helpers/typeAliases\";\nimport { util, ZodParsedType } from \"./helpers/util\";\ndeclare type allKeys<T> = T extends any ? keyof T : never;\nexport declare type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport declare type typeToFlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in allKeys<T>]?: U[];\n    };\n};\nexport declare const ZodIssueCode: {\n    invalid_type: \"invalid_type\";\n    invalid_literal: \"invalid_literal\";\n    custom: \"custom\";\n    invalid_union: \"invalid_union\";\n    invalid_union_discriminator: \"invalid_union_discriminator\";\n    invalid_enum_value: \"invalid_enum_value\";\n    unrecognized_keys: \"unrecognized_keys\";\n    invalid_arguments: \"invalid_arguments\";\n    invalid_return_type: \"invalid_return_type\";\n    invalid_date: \"invalid_date\";\n    invalid_string: \"invalid_string\";\n    too_small: \"too_small\";\n    too_big: \"too_big\";\n    invalid_intersection_types: \"invalid_intersection_types\";\n    not_multiple_of: \"not_multiple_of\";\n    not_finite: \"not_finite\";\n};\nexport declare type ZodIssueCode = keyof typeof ZodIssueCode;\nexport declare type ZodIssueBase = {\n    path: (string | number)[];\n    message?: string;\n};\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_type;\n    expected: ZodParsedType;\n    received: ZodParsedType;\n}\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_literal;\n    expected: unknown;\n}\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.unrecognized_keys;\n    keys: string[];\n}\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union;\n    unionErrors: ZodError[];\n}\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union_discriminator;\n    options: Primitive[];\n}\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n    received: string | number;\n    code: typeof ZodIssueCode.invalid_enum_value;\n    options: (string | number)[];\n}\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_arguments;\n    argumentsError: ZodError;\n}\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_return_type;\n    returnTypeError: ZodError;\n}\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_date;\n}\nexport declare type StringValidation = \"email\" | \"url\" | \"uuid\" | \"regex\" | \"cuid\" | \"datetime\" | {\n    startsWith: string;\n} | {\n    endsWith: string;\n};\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_string;\n    validation: StringValidation;\n}\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_small;\n    minimum: number;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\";\n}\nexport interface ZodTooBigIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_big;\n    maximum: number;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\";\n}\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_intersection_types;\n}\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_multiple_of;\n    multipleOf: number;\n}\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_finite;\n}\nexport interface ZodCustomIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.custom;\n    params?: {\n        [k: string]: any;\n    };\n}\nexport declare type DenormalizedError = {\n    [k: string]: DenormalizedError | string[];\n};\nexport declare type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;\nexport declare type ZodIssue = ZodIssueOptionalMessage & {\n    fatal?: boolean;\n    message: string;\n};\nexport declare const quotelessJson: (obj: any) => string;\nexport declare type ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & (NonNullable<T> extends [any, ...any[]] ? {\n    [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]>;\n} : NonNullable<T> extends any[] ? {\n    [k: number]: ZodFormattedError<NonNullable<T>[number]>;\n} : NonNullable<T> extends object ? {\n    [K in keyof NonNullable<T>]?: ZodFormattedError<NonNullable<T>[K]>;\n} : unknown);\nexport declare type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\nexport declare class ZodError<T = any> extends Error {\n    issues: ZodIssue[];\n    get errors(): ZodIssue[];\n    constructor(issues: ZodIssue[]);\n    format(): ZodFormattedError<T>;\n    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n    static create: (issues: ZodIssue[]) => ZodError<any>;\n    toString(): string;\n    get message(): string;\n    get isEmpty(): boolean;\n    addIssue: (sub: ZodIssue) => void;\n    addIssues: (subs?: ZodIssue[]) => void;\n    flatten(): typeToFlattenedError<T>;\n    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n    get formErrors(): typeToFlattenedError<T, string>;\n}\ndeclare type stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\nexport declare type IssueData = stripPath<ZodIssueOptionalMessage> & {\n    path?: (string | number)[];\n    fatal?: boolean;\n};\nexport declare type ErrorMapCtx = {\n    defaultError: string;\n    data: any;\n};\nexport declare type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {\n    message: string;\n};\nexport {};\n",
    "lib/locales/en.d.ts": "import { ZodErrorMap } from \"../ZodError\";\ndeclare const errorMap: ZodErrorMap;\nexport default errorMap;\n",
    "lib/helpers/util.d.ts": "export declare namespace util {\n    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n    export const assertEqual: <A, B>(val: AssertEqual<A, B>) => AssertEqual<A, B>;\n    export function assertIs<T>(_arg: T): void;\n    export function assertNever(_x: never): never;\n    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };\n    export const getValidEnumValues: (obj: any) => any[];\n    export const objectValues: (obj: any) => any[];\n    export const objectKeys: ObjectConstructor[\"keys\"];\n    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;\n    export type identity<T> = T;\n    export type flatten<T> = identity<{\n        [k in keyof T]: T[k];\n    }>;\n    export type noUndefined<T> = T extends undefined ? never : T;\n    export const isInteger: NumberConstructor[\"isInteger\"];\n    export function joinValues<T extends any[]>(array: T, separator?: string): string;\n    export const jsonStringifyReplacer: (_: string, value: any) => any;\n    export {};\n}\nexport declare const ZodParsedType: {\n    function: \"function\";\n    number: \"number\";\n    string: \"string\";\n    nan: \"nan\";\n    integer: \"integer\";\n    float: \"float\";\n    boolean: \"boolean\";\n    date: \"date\";\n    bigint: \"bigint\";\n    symbol: \"symbol\";\n    undefined: \"undefined\";\n    null: \"null\";\n    array: \"array\";\n    object: \"object\";\n    unknown: \"unknown\";\n    promise: \"promise\";\n    void: \"void\";\n    never: \"never\";\n    map: \"map\";\n    set: \"set\";\n};\nexport declare type ZodParsedType = keyof typeof ZodParsedType;\nexport declare const getParsedType: (data: any) => ZodParsedType;\n",
    "lib/helpers/typeAliases.d.ts": "export declare type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport declare type Scalars = Primitive | Primitive[];\n",
    "lib/helpers/partialUtil.d.ts": "import type { ZodArray, ZodNullable, ZodObject, ZodOptional, ZodTuple, ZodTupleItems, ZodTypeAny } from \"../index\";\nexport declare namespace partialUtil {\n    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<infer Shape, infer Params, infer Catchall> ? ZodObject<{\n        [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>>;\n    }, Params, Catchall> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {\n        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;\n    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;\n}\n",
    "lib/helpers/parseUtil.d.ts": "import type { IssueData, ZodErrorMap, ZodIssue } from \"../ZodError\";\nimport type { ZodParsedType } from \"./util\";\nexport declare const makeIssue: (params: {\n    data: any;\n    path: (string | number)[];\n    errorMaps: ZodErrorMap[];\n    issueData: IssueData;\n}) => ZodIssue;\nexport declare type ParseParams = {\n    path: (string | number)[];\n    errorMap: ZodErrorMap;\n    async: boolean;\n};\nexport declare type ParsePathComponent = string | number;\nexport declare type ParsePath = ParsePathComponent[];\nexport declare const EMPTY_PATH: ParsePath;\nexport interface ParseContext {\n    readonly common: {\n        readonly issues: ZodIssue[];\n        readonly contextualErrorMap?: ZodErrorMap;\n        readonly async: boolean;\n    };\n    readonly path: ParsePath;\n    readonly schemaErrorMap?: ZodErrorMap;\n    readonly parent: ParseContext | null;\n    readonly data: any;\n    readonly parsedType: ZodParsedType;\n}\nexport declare type ParseInput = {\n    data: any;\n    path: (string | number)[];\n    parent: ParseContext;\n};\nexport declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;\nexport declare type ObjectPair = {\n    key: SyncParseReturnType<any>;\n    value: SyncParseReturnType<any>;\n};\nexport declare class ParseStatus {\n    value: \"aborted\" | \"dirty\" | \"valid\";\n    dirty(): void;\n    abort(): void;\n    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;\n    static mergeObjectAsync(status: ParseStatus, pairs: {\n        key: ParseReturnType<any>;\n        value: ParseReturnType<any>;\n    }[]): Promise<SyncParseReturnType<any>>;\n    static mergeObjectSync(status: ParseStatus, pairs: {\n        key: SyncParseReturnType<any>;\n        value: SyncParseReturnType<any>;\n        alwaysSet?: boolean;\n    }[]): SyncParseReturnType;\n}\nexport interface ParseResult {\n    status: \"aborted\" | \"dirty\" | \"valid\";\n    data: any;\n}\nexport declare type INVALID = {\n    status: \"aborted\";\n};\nexport declare const INVALID: INVALID;\nexport declare type DIRTY<T> = {\n    status: \"dirty\";\n    value: T;\n};\nexport declare const DIRTY: <T>(value: T) => DIRTY<T>;\nexport declare type OK<T> = {\n    status: \"valid\";\n    value: T;\n};\nexport declare const OK: <T>(value: T) => OK<T>;\nexport declare type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport declare type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport declare type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\nexport declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;\nexport declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;\n",
    "lib/helpers/errorUtil.d.ts": "export declare namespace errorUtil {\n    type ErrMessage = string | {\n        message?: string;\n    };\n    const errToObj: (message?: ErrMessage | undefined) => {\n        message?: string | undefined;\n    };\n    const toString: (message?: ErrMessage | undefined) => string | undefined;\n}\n",
    "lib/helpers/enumUtil.d.ts": "export declare namespace enumUtil {\n    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;\n    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;\n    type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;\n    type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;\n    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;\n    export {};\n}\n",
    "lib/benchmarks/union.d.ts": "import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n",
    "lib/benchmarks/string.d.ts": "import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n",
    "lib/benchmarks/realworld.d.ts": "import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n",
    "lib/benchmarks/primitives.d.ts": "import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n",
    "lib/benchmarks/object.d.ts": "import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n",
    "lib/benchmarks/index.d.ts": "export {};\n",
    "lib/benchmarks/discriminatedUnion.d.ts": "import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n"
  },
  "groqd": {
    "dist/index.d.ts": "import * as zod from 'zod';\nimport { z } from 'zod';\nexport { z } from 'zod';\n\ntype Query = string;\ntype Payload<T extends z.ZodTypeAny> = {\n    schema: T;\n    query: Query;\n};\ndeclare class BaseQuery<T extends z.ZodTypeAny> {\n    query: string;\n    schema: T;\n    constructor({ query, schema }: Payload<T>);\n    value(): Payload<T>;\n    nullable(): NullableBaseQuery<z.ZodNullable<T>>;\n}\ndeclare class NullableBaseQuery<T extends z.ZodTypeAny> extends BaseQuery<z.ZodNullable<T>> {\n    constructor({ schema, query }: Payload<T>);\n}\n\ntype ValueOf<T> = T[keyof T];\ntype InferType<P> = P extends BaseQuery<infer T> ? T extends z.ZodType ? z.infer<T> : never : P extends z.ZodType ? z.infer<P> : never;\n/**\n * Type from selection, useful if defining conditional selections in a separate file\n *   and you want the type that you'll get from that.\n */\ntype TypeFromSelection<Sel extends Selection> = z.infer<FromSelection<Sel>>;\n/**\n * Helper to determine if list of values includes a value,\n *   used in sanityImage\n */\ntype ListIncludes<T, M> = T extends any[] ? ArrayToObj<T> extends FieldToObj<M> ? true : false : false;\ntype ArrayToObj<T extends any[]> = {\n    [K in T[number]]: true;\n};\ntype FieldToObj<T> = {\n    [K in T & string]: {\n        [Key in K]: true;\n    };\n}[T & string];\n/**\n * Misc internal utils\n */\ntype Field<T extends z.ZodType> = T;\ntype FromField<T> = T extends Field<infer R> ? R : T extends [string, infer R] ? R : never;\ntype FromSelection<Sel extends Selection> = z.ZodObject<{\n    [K in keyof Sel]: Sel[K] extends BaseQuery<any> ? Sel[K][\"schema\"] : FromField<Sel[K]>;\n}>;\ntype Selection = Record<string, BaseQuery<any> | z.ZodType | [string, z.ZodType]>;\n\n/**\n * Misc util\n */\ntype ConditionValue = Selection | BaseQuery<any> | [string, z.ZodType];\ntype ConditionRecord = Record<string, ConditionValue>;\ntype ConditionSchema<Condition extends ConditionValue> = Condition extends Selection ? FromSelection<Condition> : Condition extends BaseQuery<any> ? Condition[\"schema\"] : Condition extends [string, z.ZodType] ? Condition[1] : never;\ntype SelectSchemaType<Conditions extends ConditionRecord> = z.ZodUnion<Conditions extends {\n    default: any;\n} ? [\n    ConditionSchema<Conditions[keyof Conditions]>,\n    ConditionSchema<Conditions[keyof Conditions]>,\n    ...ConditionSchema<Conditions[keyof Conditions]>[]\n] : [\n    z.ZodNull,\n    ConditionSchema<Conditions[keyof Conditions]>,\n    ...ConditionSchema<Conditions[keyof Conditions]>[]\n]>;\ndeclare const emptyZodRecord: z.ZodRecord<z.ZodString, z.ZodNever>;\ntype EmptyZodObject = typeof emptyZodRecord;\ntype ZodObjectAny = z.ZodObject<Record<string, any>>;\ntype ZodUnionAny = z.ZodUnion<readonly [z.ZodType, ...z.ZodType[]]>;\ntype Spread<ZU extends ZodUnionAny> = ZU extends z.ZodUnion<infer T extends readonly [z.ZodType, ...z.ZodType[]]> ? z.ZodUnion<[\n    T[number] extends infer U ? U extends ZodObjectAny ? U : U extends ZodUnionAny ? Spread<U> : EmptyZodObject : never\n]> : never;\n\n/**\n * Single Entity\n */\ndeclare class EntityQuery<T extends z.ZodTypeAny> extends BaseQuery<T> {\n    constructor(payload: Payload<T>);\n    select<Conditions extends ConditionRecord>(s: Conditions): EntityQuery<Spread<SelectSchemaType<Conditions>>>;\n    select<S extends ZodUnionAny>(s: BaseQuery<S>): EntityQuery<Spread<S>>;\n    grab<S extends Selection, CondSelections extends Record<string, Selection> | undefined>(selection: S, conditionalSelections?: CondSelections): T extends z.ZodArray<any, \"many\"> ? ArrayQuery<undefined extends CondSelections ? FromSelection<S> : z.ZodUnion<[ValueOf<{ [K in keyof CondSelections]: FromSelection<S & CondSelections[K]>; }>, FromSelection<S>]>> : EntityQuery<undefined extends CondSelections ? FromSelection<S> : z.ZodUnion<[ValueOf<{ [K in keyof CondSelections]: FromSelection<S & CondSelections[K]>; }>, FromSelection<S>]>>;\n    grab$<S extends Selection, CondSelections extends Record<string, Selection> | undefined>(selection: S, conditionalSelections?: CondSelections): T extends z.ZodArray<any, \"many\"> ? ArrayQuery<undefined extends CondSelections | (NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never) ? FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; }> : z.ZodUnion<[ValueOf<{ [K_3 in keyof CondSelections]: FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; } & CondSelections[K_3]>; } | ((NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never) extends infer T_3 extends Record<string, Selection> | undefined ? { [K_4 in keyof T_3]: FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; } & (NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never)[K_4]>; } : never)>, FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; }>]>> : EntityQuery<undefined extends CondSelections | (NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never) ? FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; }> : z.ZodUnion<[ValueOf<{ [K_3 in keyof CondSelections]: FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; } & CondSelections[K_3]>; } | ((NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never) extends infer T_3 extends Record<string, Selection> | undefined ? { [K_4 in keyof T_3]: FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; } & (NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never)[K_4]>; } : never)>, FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; }>]>>;\n    grabOne<GrabOneType extends z.ZodType>(name: string, fieldSchema: GrabOneType): EntityQuery<GrabOneType>;\n    grabOne$<GrabOneType extends z.ZodType>(name: string, fieldSchema: GrabOneType): EntityQuery<z.ZodEffects<GrabOneType, z.output<GrabOneType>, z.input<GrabOneType>>>;\n}\n/**\n * Unknown, comes out of pipe and is starting point for queries.\n */\ndeclare class UnknownQuery extends EntityQuery<z.ZodUnknown> {\n    constructor(payload: Pick<Payload<z.ZodUnknown>, \"query\">);\n    filter(filterValue?: string): UnknownArrayQuery;\n    filterByType(filterTypeValue: string): UnknownArrayQuery;\n    deref(): this;\n}\n/**\n * Array\n */\ndeclare class ArrayQuery<T extends z.ZodTypeAny> extends BaseQuery<z.ZodArray<T>> {\n    constructor(payload: Payload<z.ZodArray<T>>);\n    select<Conditions extends ConditionRecord>(s: Conditions): ArrayQuery<Spread<SelectSchemaType<Conditions>>>;\n    select<S extends ZodUnionAny>(s: BaseQuery<S>): ArrayQuery<Spread<S>>;\n    filter(filterValue?: string): this;\n    filterByType(filterTypeValue: string): this;\n    grab<S extends Selection, CondSelections extends Record<string, Selection> | undefined>(selection: S, conditionalSelections?: CondSelections): ArrayQuery<undefined extends CondSelections ? FromSelection<S> : z.ZodUnion<[ValueOf<{ [K in keyof CondSelections]: FromSelection<S & CondSelections[K]>; }>, FromSelection<S>]>>;\n    grab$<S extends Selection, CondSelections extends Record<string, Selection> | undefined>(selection: S, conditionalSelections?: CondSelections): ArrayQuery<undefined extends CondSelections | (NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never) ? FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; }> : z.ZodUnion<[ValueOf<{ [K_3 in keyof CondSelections]: FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; } & CondSelections[K_3]>; } | ((NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never) extends infer T_3 extends Record<string, Selection> | undefined ? { [K_4 in keyof T_3]: FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; } & (NonNullable<CondSelections> extends infer T_1 extends Record<string, Selection> ? { [K in keyof T_1]: NonNullable<CondSelections>[K] extends infer T_2 extends Selection ? { [K_1 in keyof T_2]: NonNullable<CondSelections>[K][K_1] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<NonNullable<CondSelections>[K][K_1], z.output<NonNullable<CondSelections>[K][K_1]>, z.input<NonNullable<CondSelections>[K][K_1]>> : NonNullable<CondSelections>[K][K_1] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : NonNullable<CondSelections>[K][K_1]; } : never; } : never)[K_4]>; } : never)>, FromSelection<{ [K_2 in keyof S]: S[K_2] extends z.ZodType<any, z.ZodTypeDef, any> ? z.ZodEffects<S[K_2], z.output<S[K_2]>, z.input<S[K_2]>> : S[K_2] extends [infer R, infer ZT] ? ZT extends z.ZodType<any, z.ZodTypeDef, any> ? [R, z.ZodEffects<ZT, z.output<ZT>, z.input<ZT>>] : never : S[K_2]; }>]>>;\n    grabOne<GrabOneType extends z.ZodType>(name: string, fieldSchema: GrabOneType): ArrayQuery<GrabOneType>;\n    grabOne$<GrabOneType extends z.ZodType>(name: string, fieldSchema: GrabOneType): ArrayQuery<z.ZodEffects<GrabOneType, z.output<GrabOneType>, z.input<GrabOneType>>>;\n    order(...orderings: `${string} ${\"asc\" | \"desc\"}`[]): ArrayQuery<T>;\n    score(...scores: string[]): ArrayQuery<T>;\n    slice(index: number): EntityQuery<T>;\n    slice(min: number, max: number): ArrayQuery<T>;\n}\ndeclare class UnknownArrayQuery extends ArrayQuery<z.ZodUnknown> {\n    constructor(payload: Pick<Payload<z.ZodArray<z.ZodUnknown>>, \"query\">);\n    deref(): this;\n}\n\ndeclare const reffedAssetFields: {\n    _ref: zod.ZodString;\n    _type: zod.ZodLiteral<\"reference\">;\n};\ndeclare const cropFields: {\n    crop: zod.ZodNullable<zod.ZodObject<{\n        top: zod.ZodNumber;\n        bottom: zod.ZodNumber;\n        left: zod.ZodNumber;\n        right: zod.ZodNumber;\n    }, \"strip\", zod.ZodTypeAny, {\n        top: number;\n        bottom: number;\n        left: number;\n        right: number;\n    }, {\n        top: number;\n        bottom: number;\n        left: number;\n        right: number;\n    }>>;\n};\ndeclare const hotspotFields: {\n    hotspot: zod.ZodNullable<zod.ZodObject<{\n        x: zod.ZodNumber;\n        y: zod.ZodNumber;\n        height: zod.ZodNumber;\n        width: zod.ZodNumber;\n    }, \"strip\", zod.ZodTypeAny, {\n        x: number;\n        y: number;\n        height: number;\n        width: number;\n    }, {\n        x: number;\n        y: number;\n        height: number;\n        width: number;\n    }>>;\n};\ndeclare const refBase: {\n    readonly _key: zod.ZodNullable<zod.ZodString>;\n    readonly _type: zod.ZodString;\n};\ndeclare const dereffedAssetBaseFields: {\n    _id: zod.ZodString;\n    _type: zod.ZodLiteral<\"sanity.imageAsset\">;\n    _rev: zod.ZodString;\n    extension: zod.ZodString;\n    mimeType: zod.ZodString;\n    originalFilename: zod.ZodString;\n    path: zod.ZodString;\n    sha1hash: zod.ZodString;\n    size: zod.ZodNumber;\n    url: zod.ZodString;\n    _updatedAt: zod.ZodNullable<zod.ZodString>;\n};\ndeclare const dimensionFields: {\n    dimensions: zod.ZodNullable<zod.ZodObject<{\n        _type: zod.ZodOptional<zod.ZodLiteral<\"sanity.imageDimensions\">>;\n        aspectRatio: zod.ZodNumber;\n        height: zod.ZodNumber;\n        width: zod.ZodNumber;\n    }, \"strip\", zod.ZodTypeAny, {\n        _type?: \"sanity.imageDimensions\" | undefined;\n        height: number;\n        width: number;\n        aspectRatio: number;\n    }, {\n        _type?: \"sanity.imageDimensions\" | undefined;\n        height: number;\n        width: number;\n        aspectRatio: number;\n    }>>;\n};\ndeclare const locationFields: {\n    location: zod.ZodNullable<zod.ZodObject<{\n        _type: zod.ZodLiteral<\"geopoint\">;\n        lat: zod.ZodNumber;\n        lng: zod.ZodNumber;\n    }, \"strip\", zod.ZodTypeAny, {\n        _type: \"geopoint\";\n        lat: number;\n        lng: number;\n    }, {\n        _type: \"geopoint\";\n        lat: number;\n        lng: number;\n    }>>;\n};\ndeclare const lqipFields: {\n    lqip: zod.ZodString;\n};\ndeclare const isOpaqueFields: {\n    isOpaque: zod.ZodNullable<zod.ZodBoolean>;\n};\ndeclare const hasAlphaFields: {\n    hasAlpha: zod.ZodNullable<zod.ZodBoolean>;\n};\ndeclare const blurHashFields: {\n    blurHash: zod.ZodNullable<zod.ZodString>;\n};\ndeclare const paletteFields: {\n    palette: zod.ZodObject<{\n        darkMuted: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n        darkVibrant: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n        dominant: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n        lightMuted: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n        lightVibrant: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n        muted: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n        vibrant: zod.ZodNullable<zod.ZodObject<{\n            _type: zod.ZodLiteral<\"sanity.imagePaletteSwatch\">;\n            background: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            foreground: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n            population: zod.ZodNullable<zod.ZodOptional<zod.ZodNumber>>;\n            title: zod.ZodNullable<zod.ZodOptional<zod.ZodString>>;\n        }, \"strip\", zod.ZodTypeAny, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }, {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        }>>;\n    }, \"strip\", zod.ZodTypeAny, {\n        darkMuted: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        darkVibrant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        dominant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        lightMuted: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        lightVibrant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        muted: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        vibrant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n    }, {\n        darkMuted: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        darkVibrant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        dominant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        lightMuted: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        lightVibrant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        muted: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n        vibrant: {\n            background?: string | null | undefined;\n            foreground?: string | null | undefined;\n            population?: number | null | undefined;\n            title?: string | null | undefined;\n            _type: \"sanity.imagePaletteSwatch\";\n        } | null;\n    }>;\n};\n/**\n * Overload the imageRef so user can optionally pass a selection that gets merged into the base selection.\n */\ndeclare function sanityImage(fieldName: string): EntityQuery<FromSelection<typeof refBase & {\n    asset: EntityQuery<FromSelection<typeof reffedAssetFields>>;\n}>>;\ndeclare function sanityImage<WithCrop extends boolean | undefined = undefined, WithHotspot extends boolean | undefined = undefined, AdditionalSelection extends Selection | undefined = undefined, Multiple extends boolean | undefined = undefined, WithAsset extends readonly WithAssetOption[] | undefined = undefined>(fieldName: string, options: {\n    withCrop?: WithCrop;\n    withHotspot?: WithHotspot;\n    isList?: Multiple;\n    additionalFields?: AdditionalSelection;\n    withAsset?: WithAsset;\n}): Multiple extends true ? ArrayQuery<ImageRefSchemaType<WithCrop, WithHotspot, AdditionalSelection, WithAsset>> : EntityQuery<ImageRefSchemaType<WithCrop, WithHotspot, AdditionalSelection, WithAsset>>;\ntype Empty = Record<never, never>;\ntype ImageRefSchemaType<WithCrop extends boolean | undefined = undefined, WithHotspot extends boolean | undefined = undefined, AdditionalSelection extends Selection | undefined = undefined, WithAsset extends readonly WithAssetOption[] | undefined = undefined> = FromSelection<typeof refBase & (WithCrop extends true ? typeof cropFields : Empty) & (WithHotspot extends true ? typeof hotspotFields : Empty) & (undefined extends AdditionalSelection ? Empty : AdditionalSelection) & {\n    asset: Asset<WithAsset>;\n}>;\ntype WithAssetOption = \"base\" | \"dimensions\" | \"location\" | \"lqip\" | \"palette\" | \"isOpaque\" | \"hasAlpha\" | \"blurHash\";\ntype Asset<WithAsset extends readonly WithAssetOption[] | undefined = undefined> = EntityQuery<FromSelection<(undefined extends WithAsset ? typeof reffedAssetFields : Empty) & (ListIncludes<WithAsset, \"base\"> extends true ? typeof dereffedAssetBaseFields : Empty) & (ListIncludes<WithAsset, Exclude<WithAssetOption, \"base\">> extends true ? {\n    metadata: AssetMetadata<WithAsset>;\n} : Empty)>>;\ntype AssetMetadata<WithAsset extends readonly WithAssetOption[] | undefined = undefined> = EntityQuery<FromSelection<(ListIncludes<WithAsset, \"dimensions\"> extends true ? typeof dimensionFields : Empty) & (ListIncludes<WithAsset, \"location\"> extends true ? typeof locationFields : Empty) & (ListIncludes<WithAsset, \"lqip\"> extends true ? typeof lqipFields : Empty) & (ListIncludes<WithAsset, \"palette\"> extends true ? typeof paletteFields : Empty) & (ListIncludes<WithAsset, \"hasAlpha\"> extends true ? typeof hasAlphaFields : Empty) & (ListIncludes<WithAsset, \"isOpaque\"> extends true ? typeof isOpaqueFields : Empty) & (ListIncludes<WithAsset, \"blurHash\"> extends true ? typeof blurHashFields : Empty)>>;\n\n/**\n * Content block schema for standard content blocks.\n */\ndeclare function contentBlock(): ReturnType<typeof makeContentBlockQuery<typeof baseMarkdefsType>>;\ndeclare function contentBlock<T extends z.ZodType>(args: {\n    markDefs: T;\n}): ReturnType<typeof makeContentBlockQuery<T>>;\ndeclare function contentBlocks(): z.ZodArray<ReturnType<typeof makeContentBlockQuery<typeof baseMarkdefsType>>>;\ndeclare function contentBlocks<T extends z.ZodType>(args: {\n    markDefs: T;\n}): z.ZodArray<ReturnType<typeof makeContentBlockQuery<T>>>;\ndeclare function makeContentBlockQuery<T extends z.ZodType>(markDefs: T): z.ZodObject<{\n    _type: z.ZodLiteral<\"block\">;\n    _key: z.ZodOptional<z.ZodString>;\n    children: z.ZodArray<z.ZodObject<{\n        _key: z.ZodString;\n        _type: z.ZodString;\n        text: z.ZodString;\n        marks: z.ZodArray<z.ZodString, \"many\">;\n    }, \"strip\", z.ZodTypeAny, {\n        _type: string;\n        _key: string;\n        text: string;\n        marks: string[];\n    }, {\n        _type: string;\n        _key: string;\n        text: string;\n        marks: string[];\n    }>, \"many\">;\n    markDefs: z.ZodOptional<z.ZodArray<T, \"many\">>;\n    style: z.ZodOptional<z.ZodString>;\n    listItem: z.ZodOptional<z.ZodString>;\n    level: z.ZodOptional<z.ZodNumber>;\n}, \"strip\", z.ZodTypeAny, {\n    _key?: string | undefined;\n    markDefs?: T[\"_output\"][] | undefined;\n    style?: string | undefined;\n    listItem?: string | undefined;\n    level?: number | undefined;\n    _type: \"block\";\n    children: {\n        _type: string;\n        _key: string;\n        text: string;\n        marks: string[];\n    }[];\n}, {\n    _key?: string | undefined;\n    markDefs?: T[\"_input\"][] | undefined;\n    style?: string | undefined;\n    listItem?: string | undefined;\n    level?: number | undefined;\n    _type: \"block\";\n    children: {\n        _type: string;\n        _key: string;\n        text: string;\n        marks: string[];\n    }[];\n}>;\n\ndeclare const schemas: {\n    string: (params?: ({\n        errorMap?: z.ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: true | undefined;\n    }) | undefined) => z.ZodString;\n    number: (params?: ({\n        errorMap?: z.ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => z.ZodNumber;\n    boolean: (params?: ({\n        errorMap?: z.ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => z.ZodBoolean;\n    unknown: (params?: z.RawCreateParams) => z.ZodUnknown;\n    null: (params?: z.RawCreateParams) => z.ZodNull;\n    undefined: (params?: z.RawCreateParams) => z.ZodUndefined;\n    date: () => z.ZodEffects<z.ZodDate, Date, unknown>;\n    literal: <T extends z.Primitive>(value: T, params?: z.RawCreateParams) => z.ZodLiteral<T>;\n    union: <T_1 extends readonly [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]>(types: T_1, params?: z.RawCreateParams) => z.ZodUnion<T_1>;\n    array: <T_2 extends z.ZodTypeAny>(schema: T_2, params?: z.RawCreateParams) => z.ZodArray<T_2, \"many\">;\n    object: <T_3 extends z.ZodRawShape>(shape: T_3, params?: z.RawCreateParams) => z.ZodObject<T_3, \"strip\", z.ZodTypeAny, z.objectUtil.addQuestionMarks<{ [k_2 in keyof T_3]: T_3[k_2][\"_output\"]; }> extends infer T_4 ? { [k_1 in keyof T_4]: z.objectUtil.addQuestionMarks<{ [k in keyof T_3]: T_3[k][\"_output\"]; }>[k_1]; } : never, z.objectUtil.addQuestionMarks<{ [k_2_1 in keyof T_3]: T_3[k_2_1][\"_input\"]; }> extends infer T_5 ? { [k_3 in keyof T_5]: z.objectUtil.addQuestionMarks<{ [k_2 in keyof T_3]: T_3[k_2][\"_input\"]; }>[k_3]; } : never>;\n    slug: (fieldName: string) => [string, z.ZodString];\n    contentBlock: typeof contentBlock;\n    contentBlocks: typeof contentBlocks;\n};\n\n/**\n * Utility to create a \"query runner\" that consumes the result of the `q` function.\n */\ndeclare const makeSafeQueryRunner: <Fn extends (query: string, ...rest: any[]) => Promise<any>>(fn: Fn) => <T extends BaseType<any>>({ query, schema }: BaseQuery<T>, ...rest: ButFirst<Parameters<Fn>>) => Promise<z.TypeOf<T>>;\ndeclare class GroqdParseError extends Error {\n    readonly err: z.ZodError;\n    readonly zodError: z.ZodError;\n    constructor(err: z.ZodError);\n}\ntype BaseType<T = any> = z.ZodType<T>;\ntype ButFirst<T extends unknown[]> = T extends [unknown, ...infer U] ? U : never;\n\ndeclare function nullToUndefined<T extends z.ZodType>(schema: T): z.ZodEffects<T>;\ndeclare function nullToUndefined<T extends Selection>(selection: T): NullToUndefinedSelection<T>;\ntype NullToUndefinedSelection<Sel extends Selection> = {\n    [K in keyof Sel]: Sel[K] extends z.ZodType ? z.ZodEffects<Sel[K]> : Sel[K] extends [infer R, infer ZT] ? ZT extends z.ZodType ? [R, z.ZodEffects<ZT>] : never : Sel[K];\n};\n\ndeclare function pipe(filter: string): UnknownQuery;\ndeclare function pipe<IsArray extends boolean>(filter: string, opts: {\n    isArray: IsArray;\n}): IsArray extends true ? UnknownArrayQuery : UnknownQuery;\ndeclare namespace pipe {\n    var sanityImage: typeof sanityImage;\n    var select: <Conditions extends ConditionRecord>(conditionalSelections: Conditions) => BaseQuery<SelectSchemaType<Conditions>>;\n}\ntype Pipe = typeof pipe & typeof schemas;\ndeclare const q: Pipe;\n\nexport { GroqdParseError, InferType, Selection, TypeFromSelection, makeSafeQueryRunner, nullToUndefined, pipe, q, sanityImage };\n"
  }
}