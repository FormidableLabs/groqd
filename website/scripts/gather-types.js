#!/usr/bin/env node
const path = require("node:path");
const fs = require("node:fs/promises");
const { globSync } = require("glob");

/**
 * fn to gather declaration files from groqd and zod so
 * that we can load them into the monaco editor.
 */
(async function main() {
  const contents = {
    NOTE: "This file is automatically generated via the gather-types script",
    extraLibs: [
      ...(await readExtraLibs("zod", "zod")),
      ...(await readExtraLibs("groqd/dist", "groqd")),
      ...(await readExtraLibs("groqd-legacy/dist", "groqd-legacy")),
      ...(await readExtraLibs("type-fest", "type-fest", {
        trimComments: true,
      })),
      ...(await readExtraLibs("../src/arcade/playground", ".")),
    ],
  };

  await fs.writeFile(
    path.resolve(__dirname, "../src/types.json"),
    JSON.stringify(contents, null, 2)
  );
})();

async function readExtraLibs(
  packagePath,
  packageName,
  { trimComments = false } = {}
) {
  const ROOT = path.resolve(__dirname, "../node_modules", packagePath);
  const typeFiles = globSync(path.join(ROOT, "/**/*.d.ts"));

  const results = [];

  for (const typeFile of typeFiles) {
    let typeDefContents = await fs.readFile(typeFile, "utf8");
    if (trimComments) {
      typeDefContents = removeComments(typeDefContents);
    }
    const relative = path.relative(ROOT, typeFile);

    const isNodeModule = !packageName.startsWith(".");
    const filePath =
      (isNodeModule ? "file:///node_modules/" : "file:///") +
      path.posix.join(packageName, relative);

    // These results get bundled with the Monaco editor:
    results.push({
      filePath,
      content: typeDefContents,
    });
  }

  return results;
}

function removeComments(typescriptCode) {
  const blockComment = /\/\*(.|\s)*?\*\//gs;
  const lineComment = /\s*\/\/.*$/gm;
  const emptyLines = /^\s*$/gm;
  const trimmed = typescriptCode
    .replace(blockComment, "")
    .replace(lineComment, "")
    .replace(emptyLines, "");

  return trimmed;
}
